// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const decrementCouponQuota = `-- name: DecrementCouponQuota :execrows
UPDATE coupon SET quota = quota - 1
WHERE code = $1 AND quota > 0 AND deleted_at IS NULL
`

func (q *Queries) DecrementCouponQuota(ctx context.Context, code string) (int64, error) {
	result, err := q.db.Exec(ctx, decrementCouponQuota, code)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteTaskById = `-- name: DeleteTaskById :exec
DELETE FROM task WHERE id = $1 AND user_id = $2
`

type DeleteTaskByIdParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteTaskById(ctx context.Context, arg DeleteTaskByIdParams) error {
	_, err := q.db.Exec(ctx, deleteTaskById, arg.ID, arg.UserID)
	return err
}

const deleteUserById = `-- name: DeleteUserById :exec
DELETE FROM "user" WHERE id = $1
`

func (q *Queries) DeleteUserById(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserById, id)
	return err
}

const incrementCouponQuota = `-- name: IncrementCouponQuota :exec
UPDATE coupon SET quota = quota + 1 WHERE code = $1
`

func (q *Queries) IncrementCouponQuota(ctx context.Context, code string) error {
	_, err := q.db.Exec(ctx, incrementCouponQuota, code)
	return err
}

const insertInvoice = `-- name: InsertInvoice :one
INSERT INTO invoice (id, user_id, plan_id, ref_id, coupon_code, total_amount, qr_url, expires_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, user_id, plan_id, ref_id, coupon_code, total_amount, qr_url, expires_at, created_at
`

type InsertInvoiceParams struct {
	ID          pgtype.UUID        `json:"id"`
	UserID      pgtype.UUID        `json:"user_id"`
	PlanID      pgtype.UUID        `json:"plan_id"`
	RefID       string             `json:"ref_id"`
	CouponCode  pgtype.Text        `json:"coupon_code"`
	TotalAmount int32              `json:"total_amount"`
	QrUrl       string             `json:"qr_url"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) InsertInvoice(ctx context.Context, arg InsertInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, insertInvoice,
		arg.ID,
		arg.UserID,
		arg.PlanID,
		arg.RefID,
		arg.CouponCode,
		arg.TotalAmount,
		arg.QrUrl,
		arg.ExpiresAt,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.RefID,
		&i.CouponCode,
		&i.TotalAmount,
		&i.QrUrl,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const insertPayment = `-- name: InsertPayment :exec
INSERT INTO payment (id, user_id, invoice_id, amount_paid, status) VALUES ($1, $2, $3, $4, $5)
`

type InsertPaymentParams struct {
	ID         pgtype.UUID `json:"id"`
	UserID     pgtype.UUID `json:"user_id"`
	InvoiceID  pgtype.UUID `json:"invoice_id"`
	AmountPaid int32       `json:"amount_paid"`
	Status     string      `json:"status"`
}

func (q *Queries) InsertPayment(ctx context.Context, arg InsertPaymentParams) error {
	_, err := q.db.Exec(ctx, insertPayment,
		arg.ID,
		arg.UserID,
		arg.InvoiceID,
		arg.AmountPaid,
		arg.Status,
	)
	return err
}

type InsertPrayersParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
	Name   string      `json:"name"`
	Year   int16       `json:"year"`
	Month  int16       `json:"month"`
	Day    int16       `json:"day"`
}

const insertRefreshToken = `-- name: InsertRefreshToken :exec
INSERT INTO refresh_token (id, user_id, expires_at) VALUES ($1, $2, $3)
`

type InsertRefreshTokenParams struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) InsertRefreshToken(ctx context.Context, arg InsertRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, insertRefreshToken, arg.ID, arg.UserID, arg.ExpiresAt)
	return err
}

const insertSubscription = `-- name: InsertSubscription :exec
INSERT INTO subscription (id, user_id, plan_id, payment_id, start_date, end_date) VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertSubscriptionParams struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	PlanID    pgtype.UUID        `json:"plan_id"`
	PaymentID pgtype.UUID        `json:"payment_id"`
	StartDate pgtype.Timestamptz `json:"start_date"`
	EndDate   pgtype.Timestamptz `json:"end_date"`
}

func (q *Queries) InsertSubscription(ctx context.Context, arg InsertSubscriptionParams) error {
	_, err := q.db.Exec(ctx, insertSubscription,
		arg.ID,
		arg.UserID,
		arg.PlanID,
		arg.PaymentID,
		arg.StartDate,
		arg.EndDate,
	)
	return err
}

const insertTask = `-- name: InsertTask :one
INSERT INTO task (id, user_id, name, description) VALUES ($1, $2, $3, $4) RETURNING id, user_id, name, description, checked
`

type InsertTaskParams struct {
	ID          pgtype.UUID `json:"id"`
	UserID      pgtype.UUID `json:"user_id"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
}

func (q *Queries) InsertTask(ctx context.Context, arg InsertTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, insertTask,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Checked,
	)
	return i, err
}

const insertUser = `-- name: InsertUser :one
INSERT INTO "user" (id, email, password, name, coordinates, city, timezone) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, email, password, name, coordinates, city, timezone, created_at
`

type InsertUserParams struct {
	ID          pgtype.UUID  `json:"id"`
	Email       string       `json:"email"`
	Password    string       `json:"password"`
	Name        string       `json:"name"`
	Coordinates pgtype.Point `json:"coordinates"`
	City        string       `json:"city"`
	Timezone    string       `json:"timezone"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, insertUser,
		arg.ID,
		arg.Email,
		arg.Password,
		arg.Name,
		arg.Coordinates,
		arg.City,
		arg.Timezone,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Coordinates,
		&i.City,
		&i.Timezone,
		&i.CreatedAt,
	)
	return i, err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
UPDATE refresh_token SET revoked = TRUE WHERE id = $1 AND user_id = $2
`

type RevokeRefreshTokenParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) RevokeRefreshToken(ctx context.Context, arg RevokeRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, revokeRefreshToken, arg.ID, arg.UserID)
	return err
}

const selectActiveInvoice = `-- name: SelectActiveInvoice :one
SELECT i.id, i.user_id, i.plan_id, i.ref_id, i.coupon_code, i.total_amount, i.qr_url, i.expires_at, i.created_at FROM invoice i
WHERE i.user_id = $1 AND i.expires_at > NOW()
AND NOT EXISTS (
    SELECT 1 
    FROM payment p 
    WHERE p.invoice_id = i.id
)
`

func (q *Queries) SelectActiveInvoice(ctx context.Context, userID pgtype.UUID) (Invoice, error) {
	row := q.db.QueryRow(ctx, selectActiveInvoice, userID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.RefID,
		&i.CouponCode,
		&i.TotalAmount,
		&i.QrUrl,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const selectActiveSubscription = `-- name: SelectActiveSubscription :one
SELECT id, user_id, plan_id, payment_id, start_date, end_date FROM subscription WHERE user_id = $1 AND end_date > NOW()
`

func (q *Queries) SelectActiveSubscription(ctx context.Context, userID pgtype.UUID) (Subscription, error) {
	row := q.db.QueryRow(ctx, selectActiveSubscription, userID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.PaymentID,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const selectPayments = `-- name: SelectPayments :many
SELECT id, user_id, invoice_id, amount_paid, status, created_at FROM payment WHERE user_id = $1
`

func (q *Queries) SelectPayments(ctx context.Context, userID pgtype.UUID) ([]Payment, error) {
	rows, err := q.db.Query(ctx, selectPayments, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.InvoiceID,
			&i.AmountPaid,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectPlanById = `-- name: SelectPlanById :one
SELECT id, type, name, price, duration_in_months, created_at, deleted_at FROM plan WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SelectPlanById(ctx context.Context, id pgtype.UUID) (Plan, error) {
	row := q.db.QueryRow(ctx, selectPlanById, id)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Price,
		&i.DurationInMonths,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const selectPlanByInvoiceId = `-- name: SelectPlanByInvoiceId :one
SELECT p.id, p.type, p.name, p.price, p.duration_in_months, p.created_at, p.deleted_at FROM invoice i JOIN plan p ON i.plan_id = p.id WHERE i.id = $1
`

func (q *Queries) SelectPlanByInvoiceId(ctx context.Context, id pgtype.UUID) (Plan, error) {
	row := q.db.QueryRow(ctx, selectPlanByInvoiceId, id)
	var i Plan
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Price,
		&i.DurationInMonths,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const selectPlans = `-- name: SelectPlans :many
SELECT id, type, name, price, duration_in_months, created_at, deleted_at FROM plan WHERE deleted_at IS NULL
`

func (q *Queries) SelectPlans(ctx context.Context) ([]Plan, error) {
	rows, err := q.db.Query(ctx, selectPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Plan
	for rows.Next() {
		var i Plan
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Name,
			&i.Price,
			&i.DurationInMonths,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectPrayers = `-- name: SelectPrayers :many
SELECT id, user_id, name, status, year, month, day FROM prayer WHERE user_id = $1 AND year = $2 AND month = $3 AND (day = $4 OR $4 IS NULL)
`

type SelectPrayersParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Year   int16       `json:"year"`
	Month  int16       `json:"month"`
	Day    pgtype.Int2 `json:"day"`
}

func (q *Queries) SelectPrayers(ctx context.Context, arg SelectPrayersParams) ([]Prayer, error) {
	rows, err := q.db.Query(ctx, selectPrayers,
		arg.UserID,
		arg.Year,
		arg.Month,
		arg.Day,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Prayer
	for rows.Next() {
		var i Prayer
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Status,
			&i.Year,
			&i.Month,
			&i.Day,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRefreshTokenById = `-- name: SelectRefreshTokenById :one
SELECT id, user_id, revoked, expires_at FROM refresh_token WHERE id = $1 AND user_id = $2
`

type SelectRefreshTokenByIdParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) SelectRefreshTokenById(ctx context.Context, arg SelectRefreshTokenByIdParams) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, selectRefreshTokenById, arg.ID, arg.UserID)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Revoked,
		&i.ExpiresAt,
	)
	return i, err
}

const selectTasksByUserId = `-- name: SelectTasksByUserId :many
SELECT id, user_id, name, description, checked FROM task WHERE user_id = $1
`

func (q *Queries) SelectTasksByUserId(ctx context.Context, userID pgtype.UUID) ([]Task, error) {
	rows, err := q.db.Query(ctx, selectTasksByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Checked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUserByEmailAndPassword = `-- name: SelectUserByEmailAndPassword :one
SELECT id, email, password, name, coordinates, city, timezone, created_at FROM "user" WHERE email = $1 AND password = $2
`

type SelectUserByEmailAndPasswordParams struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) SelectUserByEmailAndPassword(ctx context.Context, arg SelectUserByEmailAndPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, selectUserByEmailAndPassword, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Coordinates,
		&i.City,
		&i.Timezone,
		&i.CreatedAt,
	)
	return i, err
}

const selectUserById = `-- name: SelectUserById :one
SELECT id, email, password, name, coordinates, city, timezone, created_at FROM "user" WHERE id = $1
`

func (q *Queries) SelectUserById(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, selectUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Coordinates,
		&i.City,
		&i.Timezone,
		&i.CreatedAt,
	)
	return i, err
}

const selectUserByInvoiceId = `-- name: SelectUserByInvoiceId :one
SELECT u.id, u.email, u.password, u.name, u.coordinates, u.city, u.timezone, u.created_at FROM invoice i JOIN "user" u ON i.user_id = u.id WHERE i.id = $1
`

func (q *Queries) SelectUserByInvoiceId(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, selectUserByInvoiceId, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.Name,
		&i.Coordinates,
		&i.City,
		&i.Timezone,
		&i.CreatedAt,
	)
	return i, err
}

const updatePrayerStatus = `-- name: UpdatePrayerStatus :exec
UPDATE prayer SET status = $2 WHERE id = $1
`

type UpdatePrayerStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdatePrayerStatus(ctx context.Context, arg UpdatePrayerStatusParams) error {
	_, err := q.db.Exec(ctx, updatePrayerStatus, arg.ID, arg.Status)
	return err
}

const updateTaskById = `-- name: UpdateTaskById :one
UPDATE task SET name = $3, description = $4, checked = $5 WHERE id = $1 AND user_id = $2 RETURNING id, user_id, name, description, checked
`

type UpdateTaskByIdParams struct {
	ID          pgtype.UUID `json:"id"`
	UserID      pgtype.UUID `json:"user_id"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Checked     bool        `json:"checked"`
}

func (q *Queries) UpdateTaskById(ctx context.Context, arg UpdateTaskByIdParams) (Task, error) {
	row := q.db.QueryRow(ctx, updateTaskById,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Checked,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Checked,
	)
	return i, err
}

const updateUserCoordinatesById = `-- name: UpdateUserCoordinatesById :exec
UPDATE "user" SET coordinates = $2, city = $3, timezone = $4 WHERE id = $1
`

type UpdateUserCoordinatesByIdParams struct {
	ID          pgtype.UUID  `json:"id"`
	Coordinates pgtype.Point `json:"coordinates"`
	City        string       `json:"city"`
	Timezone    string       `json:"timezone"`
}

func (q *Queries) UpdateUserCoordinatesById(ctx context.Context, arg UpdateUserCoordinatesByIdParams) error {
	_, err := q.db.Exec(ctx, updateUserCoordinatesById,
		arg.ID,
		arg.Coordinates,
		arg.City,
		arg.Timezone,
	)
	return err
}
